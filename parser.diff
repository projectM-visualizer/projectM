diff --git a/src/libprojectM/MilkdropPresetFactory/Expr.hpp b/src/libprojectM/MilkdropPresetFactory/Expr.hpp
index 2757289c..c6ac6978 100755
--- a/src/libprojectM/MilkdropPresetFactory/Expr.hpp
+++ b/src/libprojectM/MilkdropPresetFactory/Expr.hpp
@@ -138,15 +138,15 @@ inline std::ostream& operator<<(std::ostream& out, Expr *expr)
 class TreeExpr : public Expr
 {
 protected:
-  TreeExpr( InfixOp *infix_op, Expr *gen_expr, Expr *left, Expr *right );
+  TreeExpr( InfixOp *infix_op, GenExpr *gen_expr, GenExpr *left, GenExpr *right );
 public:
-  static TreeExpr *create( InfixOp *infix_op, Expr *gen_expr, TreeExpr *left, TreeExpr *right );
-  static TreeExpr *create( InfixOp *infix_op, Expr *left, Expr *right );
+  static TreeExpr *create( InfixOp *infix_op, GenExpr *gen_expr, TreeExpr *left, TreeExpr *right );
+  static TreeExpr *create( InfixOp *infix_op, GenExpr *left, GenExpr *right );
 
   InfixOp * infix_op; /* null if leaf */
-  Expr * gen_expr;
+  GenExpr * gen_expr;
   // NOTE: before optimize() left and right will always be TreeExpr
-  Expr *left, *right;
+  GenExpr *left, *right;
   // these are for type-safe access in Parser.cpp
   TreeExpr *leftTree()  { return dynamic_cast<TreeExpr *>(left); }
   TreeExpr *rightTree() { return dynamic_cast<TreeExpr *>(right); }
diff --git a/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.cpp b/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.cpp
index 739183de..4f42a10e 100755
--- a/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.cpp
+++ b/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.cpp
@@ -113,7 +113,7 @@ MilkdropPreset::~MilkdropPreset()
 /* Adds a per pixel equation according to its string name. This
    will be used only by the parser */
 
-int MilkdropPreset::add_per_pixel_eqn(char * name, Expr * gen_expr)
+int MilkdropPreset::add_per_pixel_eqn(char * name, GenExpr * gen_expr)
 {
 
   PerPixelEqn * per_pixel_eqn = NULL;
diff --git a/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.hpp b/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.hpp
index c10fa43c..ce067337 100644
--- a/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.hpp
+++ b/src/libprojectM/MilkdropPresetFactory/MilkdropPreset.hpp
@@ -51,6 +51,7 @@ class MilkdropPresetFactory;
 class CustomWave;
 class CustomShape;
 class InitCond;
+class GenExpr;
 
 
 class MilkdropPreset : public Preset
@@ -96,7 +97,7 @@ public:
 
   /// Used by parser
   /// @bug refactor
-  int add_per_pixel_eqn( char *name, Expr *gen_expr );
+  int add_per_pixel_eqn( char *name, GenExpr *gen_expr );
 
   /// Accessor method to retrieve the absolute file path of the loaded MilkdropPreset
   /// \returns a file path string
diff --git a/src/libprojectM/MilkdropPresetFactory/Parser.cpp b/src/libprojectM/MilkdropPresetFactory/Parser.cpp
index 0b6c71a0..412e1319 100755
--- a/src/libprojectM/MilkdropPresetFactory/Parser.cpp
+++ b/src/libprojectM/MilkdropPresetFactory/Parser.cpp
@@ -24,7 +24,6 @@
 #include <string>
 #include <cstring>
 #include <iostream>
-#include <locale>
 #include <stdlib.h>
 
 #include "Common.hpp"
@@ -47,27 +46,32 @@
 #include <iostream>
 #include <sstream>
 #include "BuiltinFuncs.hpp"
-#include "MilkdropPresetFactory.hpp"
 
 /* Grabs the next token from the file. The second argument points
    to the raw string */
+Parser::Parser()
+{
+  lastLinePrefix = "";
+  tokenWrapAroundEnabled = false;
+  current_wave = NULL;
+  current_shape = NULL;
+  string_line_buffer_index=0;
+  line_count = 0;
+  per_frame_eqn_count= 0;
+  per_frame_init_eqn_count = 0;
+  last_custom_wave_id = 0;
+  last_custom_shape_id = 0;
+  last_token_size = 0;
+  memset(string_line_buffer, 0, STRING_LINE_SIZE);
+  memset(last_eqn_type, 0, MAX_TOKEN_SIZE);
+  builtinFuncs = new BuiltinFuncs();
+  eval = new Eval();
+}
 
-line_mode_t Parser::line_mode;
-CustomWave *Parser::current_wave;
-CustomShape *Parser::current_shape;
-int Parser::string_line_buffer_index;
-char Parser::string_line_buffer[STRING_LINE_SIZE];
-unsigned int Parser::line_count;
-int Parser::per_frame_eqn_count;
-int Parser::per_frame_init_eqn_count;
-int Parser::last_custom_wave_id;
-int Parser::last_custom_shape_id;
-char Parser::last_eqn_type[MAX_TOKEN_SIZE+1];
-int Parser::last_token_size;
-
-std::string Parser::lastLinePrefix("");
-
-bool Parser::tokenWrapAroundEnabled(false);
+Parser::~Parser() {
+ delete(eval);
+ delete(builtinFuncs);
+}
 
 token_t Parser::parseToken(std::istream &  fs, char * string)
 {
@@ -168,7 +172,7 @@ token_t Parser::parseToken(std::istream &  fs, char * string)
 
       if (tokenWrapAroundEnabled)
       {
-	std::ostringstream buffer;
+    std::ostringstream buffer;
 
         if (PARSE_DEBUG) std::cerr << "token wrap! line " << line_count << std::endl;
         while (c != '=')
@@ -183,32 +187,28 @@ token_t Parser::parseToken(std::istream &  fs, char * string)
           }
 
           else {
-	    c = fs.get();
-	    if ( c != '=')
-            	buffer << (char)c;
-	}
+        c = fs.get();
+        if ( c != '=')
+                buffer << (char)c;
+    }
 
         }
         if (PARSE_DEBUG) std::cerr << "parseToken: parsed away equal sign, line prefix is \""  << buffer.str()
-		<< "\"" << std::endl;
+        << "\"" << std::endl;
         --i;
 
-	if (!wrapsToNextLine(buffer.str())) {
-		tokenWrapAroundEnabled = false;
-		int buf_size = (int)buffer.str().length();
-		// <= to also remove equal sign parsing from stream
-		for (int k = 0; k <= buf_size; k++) {
-			if (fs)
-				fs.unget();
-			else	{
-				std::cerr << "about to abort!  buf_size was " << buf_size << std::endl;
-				//	aborting kills the process, so instead of that we return a constant indicating an error, and hope that the lib bails gracefully
-				//abort();
-				return tStringTooLong;
-			}
-		}
-		return tEOL;
-	}
+    if (!wrapsToNextLine(buffer.str())) {
+        tokenWrapAroundEnabled = false;
+        int buf_size = (int)buffer.str().length();
+        // <= to also remove equal sign parsing from stream
+        for (int k = 0; k <= buf_size; k++) {
+            if (fs)
+                fs.unget();
+            else
+                abort();
+        }
+        return tEOL;
+    }
 
 
         break;
@@ -235,8 +235,8 @@ token_t Parser::parseToken(std::istream &  fs, char * string)
       i--;
       break;
     default:
-    	if (c == EOF)
-    		std::cerr << "shouldn't happen: " << c << "(LINE " << line_count << ")" << std::endl;
+        if (c == EOF)
+            std::cerr << "shouldn't happen: " << c << "(LINE " << line_count << ")" << std::endl;
         string[i] = tolower(c);
         //string[i+1] = 0;
         //std::cerr << "string is \n\"" << string << "\"" << std::endl;
@@ -253,15 +253,15 @@ token_t Parser::parseToken(std::istream &  fs, char * string)
 /* Parse input in the form of "exp, exp, exp, ...)"
    Returns a general expression list */
 
-Expr **Parser::parse_prefix_args(std::istream &  fs, int num_args, MilkdropPreset * preset)
+GenExpr **Parser::parse_prefix_args(std::istream &  fs, int num_args, MilkdropPreset * preset)
 {
 
   int i, j;
-  Expr ** expr_list; /* List of arguments to function */
-  Expr * gen_expr;
+  GenExpr ** expr_list; /* List of arguments to function */
+  GenExpr * gen_expr;
 
   /* Malloc the expression list */
-  expr_list =  (Expr**)wipemalloc(sizeof(Expr*)*num_args);
+  expr_list =  (GenExpr**)wipemalloc(sizeof(GenExpr*)*num_args);
 
   /* Malloc failed */
   if (expr_list == NULL)
@@ -278,8 +278,9 @@ Expr **Parser::parse_prefix_args(std::istream &  fs, int num_args, MilkdropPrese
     {
       //if (PARSE_DEBUG) printf("parse_prefix_args: failed to get parameter # %d for function (LINE %d)\n", i+1, line_count);
       for (j = 0; j < i; j++)
-        Expr::delete_expr(expr_list[j]);
+        delete expr_list[j];
       free(expr_list);
+      expr_list = NULL;
       return NULL;
     }
     /* Assign entry in expression list */
@@ -332,12 +333,12 @@ int Parser::parse_per_pixel_eqn(std::istream &  fs, MilkdropPreset * preset, cha
 
 
   char string[MAX_TOKEN_SIZE];
-  Expr * gen_expr;
+  GenExpr * gen_expr;
 
 
   if (init_string != 0)
   {
-    memcpy(string, init_string, strlen(init_string) + 1);
+    strncpy(string, init_string, strlen(init_string));
   }
   else
   {
@@ -361,7 +362,7 @@ int Parser::parse_per_pixel_eqn(std::istream &  fs, MilkdropPreset * preset, cha
     {
 
     }
-    Expr::delete_expr(gen_expr);
+    delete gen_expr;
     return PROJECTM_PARSE_ERROR;
   }
 
@@ -430,35 +431,35 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
     if (!fs)
       return PROJECTM_PARSE_ERROR;
 
-//	char z = fs.get();
-	char tmpChar;
-	if ((tmpChar = fs.get()) == '\n') {
-		tokenWrapAroundEnabled = false;
-		return PROJECTM_PARSE_ERROR;
-	} else if (tmpChar == '\r') {
-		tokenWrapAroundEnabled = false;
-		return PROJECTM_PARSE_ERROR;
-	} else
-		fs.unget();
+//    char z = fs.get();
+    char tmpChar;
+    if ((tmpChar = fs.get()) == '\n') {
+        tokenWrapAroundEnabled = false;
+        return PROJECTM_PARSE_ERROR;
+    } else if (tmpChar == '\r') {
+        tokenWrapAroundEnabled = false;
+        return PROJECTM_PARSE_ERROR;
+    } else
+        fs.unget();
 
 
 
-	/* CASE: WARP CODE */
-	if (!strncmp(eqn_string, WARP_STRING, WARP_STRING_LENGTH))
-	{
-		//std::cout << "parsing warp string block\n" << std::endl;
-		parse_string_block(fs, &preset->presetOutputs().warpShader.programSource);
-		return PROJECTM_SUCCESS;
-	}
+    /* CASE: WARP CODE */
+    if (!strncmp(eqn_string, WARP_STRING, WARP_STRING_LENGTH))
+    {
+        //std::cout << "parsing warp string block\n" << std::endl;
+        parse_string_block(fs, &preset->presetOutputs().warpShader.programSource);
+        return PROJECTM_SUCCESS;
+    }
 
 
-	/* CASE: COMPOSITE CODE */
-	if (!strncmp(eqn_string, COMPOSITE_STRING, COMPOSITE_STRING_LENGTH))
-	{
-		//std::cout << "parsing composite string block\n" << std::endl;
-		parse_string_block(fs, &preset->presetOutputs().compositeShader.programSource);
-		return PROJECTM_SUCCESS;
-	}
+    /* CASE: COMPOSITE CODE */
+    if (!strncmp(eqn_string, COMPOSITE_STRING, COMPOSITE_STRING_LENGTH))
+    {
+        //std::cout << "parsing composite string block\n" << std::endl;
+        parse_string_block(fs, &preset->presetOutputs().compositeShader.programSource);
+        return PROJECTM_SUCCESS;
+    }
 
     /* CASE: PER FRAME INIT EQUATION */
     if (!strncmp(eqn_string, PER_FRAME_INIT_STRING, PER_FRAME_INIT_STRING_LENGTH))
@@ -484,7 +485,7 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
     /* Per frame equation case */
     if (!strncmp(eqn_string, PER_FRAME_STRING, PER_FRAME_STRING_LENGTH))
     {
-	tokenWrapAroundEnabled = true;
+    tokenWrapAroundEnabled = true;
       /* Sometimes per frame equations are implicitly defined without the
       per_frame_ prefix. This informs the parser that one could follow */
       line_mode = PER_FRAME_LINE_MODE;
@@ -519,7 +520,7 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
     if ((!strncmp(eqn_string, WAVE_STRING, WAVE_STRING_LENGTH)) &&
         ((eqn_string[5] >= 48) && (eqn_string[5] <= 57)))
     {
-	tokenWrapAroundEnabled = true;
+    tokenWrapAroundEnabled = true;
       //    if (PARSE_DEBUG) printf("parse_line wave prefix found: \"%s\"\n", eqn_string);
 
       return parse_wave(eqn_string, fs, preset);
@@ -533,7 +534,7 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
 
       line_mode = CUSTOM_SHAPE_SHAPECODE_LINE_MODE;
 
-      if (PARSE_DEBUG) printf("parse_line: shapecode prefix found: \"%s\"\n", eqn_string);
+      if (PARSE_DEBUG) std::cerr << "parse_line: shapecode prefix found:" << eqn_string << std::endl;
 
       return parse_shapecode(eqn_string, fs, preset);
     }
@@ -543,7 +544,7 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
         ((eqn_string[6] >= 48) && (eqn_string[6] <= 57)))
     {
       tokenWrapAroundEnabled = true;
-      if (PARSE_DEBUG) printf("parse_line shape prefix found: \"%s\"\n", eqn_string);
+        if (PARSE_DEBUG) std::cerr << "parse_line shape prefix found: " << eqn_string << std::endl;
       return parse_shape(eqn_string, fs, preset);
 
     }
@@ -562,7 +563,7 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
       }
 
 
-      if (PARSE_DEBUG) printf("parse_line: finished parsing per pixel equation (LINE %d)\n", line_count);
+        if (PARSE_DEBUG) std::cerr << "parse_line: finished parsing per pixel equation (LINE " << line_count << ")" << std::endl;
       return PROJECTM_SUCCESS;
     }
 
@@ -716,17 +717,19 @@ int Parser::parse_line(std::istream &  fs, MilkdropPreset * preset)
 }
 
 
+
 /* Parses a general expression, this function is the meat of the parser */
-Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, MilkdropPreset * preset)
+GenExpr * Parser::parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, MilkdropPreset * preset)
 {
+
   int i;
   char string[MAX_TOKEN_SIZE];
   token_t token;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
   float val;
   Param * param = NULL;
   Func * func;
-  Expr ** expr_list;
+  GenExpr ** expr_list;
 
   switch (token = parseToken(fs,string))
   {
@@ -734,7 +737,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
   case tLPr:
     //std::cerr << "token before tLPr:" << string << std::endl;
     /* CASE 1 (Left Parentice): See if the previous string before this parentice is a function name */
-    if ((func = BuiltinFuncs::find_func(string)) != NULL)
+    if ((func = builtinFuncs->find_func(string)) != NULL)
     {
       if (PARSE_DEBUG)
       {
@@ -752,21 +755,22 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
         }
         if ( tree_expr != NULL )
         {
-          Expr::delete_expr(tree_expr);
+          delete tree_expr;
         }
         return NULL;
       }
 
       /* Convert function to expression */
-      if ((gen_expr = Expr::prefun_to_expr(func, expr_list)) == NULL)
+      if ((gen_expr = GenExpr::prefun_to_expr((float (*)(void *))func->func_ptr, expr_list, func->getNumArgs())) == NULL)
       {
         if (PARSE_DEBUG) printf("parse_prefix_args: failed to convert prefix function to general expression (LINE %d) \n",
                                   line_count);
         if (tree_expr)
-          Expr::delete_expr(tree_expr);
+          delete tree_expr;
         for (i = 0; i < func->getNumArgs();i++)
-          Expr::delete_expr(expr_list[i]);
+          delete expr_list[i];
         free(expr_list);
+        expr_list = NULL;
         return NULL;
       }
 
@@ -789,7 +793,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
       std::cerr << "token prefix is " << *string << std::endl;
       if (PARSE_DEBUG) printf("parse_gen_expr: implicit multiplication case unimplemented!\n");
       if (tree_expr)
-        Expr::delete_expr(tree_expr);
+        delete tree_expr;
       return NULL;
     }
 
@@ -800,7 +804,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
     {
       if (PARSE_DEBUG) printf("parse_gen_expr:  found left parentice, but failed to create new expression tree \n");
       if (tree_expr)
-      Expr::delete_expr(tree_expr);
+      delete tree_expr;
       return NULL;
     }
 
@@ -816,7 +820,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
       if (PARSE_DEBUG) printf("parse_gen_expr: plus used as prefix (LINE %d)\n", line_count);
 
       /* Treat prefix plus as implict 0 preceding operator */
-      gen_expr = Expr::const_to_expr(0);
+      gen_expr = GenExpr::const_to_expr(0);
 
       return parse_infix_op(fs, tPositive, insert_gen_expr(gen_expr, &tree_expr), preset);
     }
@@ -827,7 +831,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
     {
 
       /* Use the negative infix operator, but first add an implicit zero to the operator tree */
-      gen_expr = Expr::const_to_expr(0);
+      gen_expr = GenExpr::const_to_expr(0);
       //return parse_gen_expr(fs, insert_gen_expr(gen_expr, &tree_expr), preset);
       return parse_infix_op(fs, tNegative, insert_gen_expr(gen_expr, &tree_expr), preset);
     }
@@ -854,17 +858,17 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
     if (*string == 0)
     {
       if (tree_expr)
-        Expr::delete_expr(tree_expr);
+        delete tree_expr;
       return NULL;
     }
 
     /* CASE 1: Check if string is a just a floating point number */
     if (string_to_float(string, &val) != PROJECTM_PARSE_ERROR)
     {
-      if ((gen_expr = Expr::const_to_expr(val)) == NULL)
+      if ((gen_expr = GenExpr::const_to_expr(val)) == NULL)
       {
         if (tree_expr)
-          Expr::delete_expr(tree_expr);
+          delete tree_expr;
         return NULL;
       }
 
@@ -883,7 +887,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
           if ((param = ParamUtils::find<ParamUtils::AUTO_CREATE>(std::string(string), &current_shape->param_tree)) == NULL)
           {
             if (tree_expr)
-              Expr::delete_expr(tree_expr);
+              delete tree_expr;
             return NULL;
           }
       }
@@ -896,9 +900,9 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
 
 
       /* Convert parameter to an expression */
-      if ((gen_expr = Expr::param_to_expr(param)) == NULL)
+      if ((gen_expr = GenExpr::param_to_expr(param)) == NULL)
       {
-        Expr::delete_expr(tree_expr);
+        delete tree_expr;
         return NULL;
       }
 
@@ -917,7 +921,7 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
           if ((param = ParamUtils::find<ParamUtils::AUTO_CREATE>(std::string(string), &current_wave->param_tree)) == NULL)
           {
             if (tree_expr)
-              Expr::delete_expr(tree_expr);
+              delete tree_expr;
             return NULL;
           }
       }
@@ -930,9 +934,9 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
       }
 
       /* Convert parameter to an expression */
-      if ((gen_expr = Expr::param_to_expr(param)) == NULL)
+      if ((gen_expr = GenExpr::param_to_expr(param)) == NULL)
       {
-        Expr::delete_expr(tree_expr);
+        delete tree_expr;
         return NULL;
       }
 
@@ -953,9 +957,9 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
       }
 
       /* Convert parameter to an expression */
-      if ((gen_expr = Expr::param_to_expr(param)) == NULL)
+      if ((gen_expr = GenExpr::param_to_expr(param)) == NULL)
       {
-        Expr::delete_expr(tree_expr);
+        delete tree_expr;
         return NULL;
       }
 
@@ -973,24 +977,12 @@ Expr * Parser::_parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, Milkd
 
     }
     if (tree_expr)
-      Expr::delete_expr(tree_expr);
+      delete tree_expr;
     return NULL;
   }
 }
 
 
-Expr * Parser::parse_gen_expr ( std::istream &  fs, TreeExpr * tree_expr, MilkdropPreset * preset)
-{
-  Expr *gen_expr = _parse_gen_expr( fs, tree_expr, preset );
-  if (nullptr == gen_expr)
-    return nullptr;
-  //std::cout << gen_expr << std::endl;
-  Expr *opt = Expr::optimize(gen_expr);
-  gen_expr = nullptr;
-  //std::cout << opt << std::endl << std::endl;
-  return opt;
-}
-
 
 /* Inserts expressions into tree according to operator precedence.
    If root is null, a new tree is created, with infix_op as only element */
@@ -1009,7 +1001,7 @@ TreeExpr * Parser::insert_infix_op(InfixOp * infix_op, TreeExpr **root)
 
   if (*root == NULL)
   {
-    new_root = TreeExpr::create(infix_op, NULL, NULL, NULL);
+    new_root = new TreeExpr(infix_op, NULL, NULL, NULL);
     *root = new_root;
     return new_root;
   }
@@ -1019,7 +1011,7 @@ TreeExpr * Parser::insert_infix_op(InfixOp * infix_op, TreeExpr **root)
 
   if ((*root)->infix_op == NULL)
   {
-    new_root = TreeExpr::create(infix_op, NULL, *root, NULL);
+    new_root = new TreeExpr(infix_op, NULL, *root, NULL);
     (*root) = new_root;
     return new_root;
   }
@@ -1028,9 +1020,9 @@ TreeExpr * Parser::insert_infix_op(InfixOp * infix_op, TreeExpr **root)
      of the item to be inserted is greater than the root's
      precedence, then make gen_expr the root */
 
-  if (infix_op->precedence >= (*root)->infix_op->precedence)
+  if (infix_op->precedence > (*root)->infix_op->precedence)
   {
-    new_root = TreeExpr::create(infix_op, NULL, *root, NULL);
+    new_root = new TreeExpr(infix_op, NULL, *root, NULL);
     (*root) = new_root;
     return new_root;
   }
@@ -1045,7 +1037,7 @@ TreeExpr * Parser::insert_infix_op(InfixOp * infix_op, TreeExpr **root)
 }
 
 
-TreeExpr * Parser::insert_gen_expr(Expr * gen_expr, TreeExpr ** root)
+TreeExpr * Parser::insert_gen_expr(GenExpr * gen_expr, TreeExpr ** root)
 {
 
   TreeExpr * new_root;
@@ -1063,7 +1055,7 @@ TreeExpr * Parser::insert_gen_expr(Expr * gen_expr, TreeExpr ** root)
 
   if (*root == NULL)
   {
-    new_root = TreeExpr::create(NULL, gen_expr, NULL, NULL);
+    new_root = new TreeExpr(NULL, gen_expr, NULL, NULL);
     *root = new_root;
     return new_root;
   }
@@ -1077,7 +1069,7 @@ TreeExpr * Parser::insert_gen_expr(Expr * gen_expr, TreeExpr ** root)
 }
 
 /* A recursive helper function to insert general expression elements into the operator tree */
-int Parser::insert_gen_rec(Expr * gen_expr, TreeExpr * root)
+int Parser::insert_gen_rec(GenExpr * gen_expr, TreeExpr * root)
 {
 
   /* Trivial Case: root is null */
@@ -1095,7 +1087,7 @@ int Parser::insert_gen_rec(Expr * gen_expr, TreeExpr * root)
 
   if ((root->left == NULL) && (root->infix_op != NULL))
   {
-    root->left = TreeExpr::create(NULL, gen_expr, NULL, NULL);
+    root->left = new TreeExpr(NULL, gen_expr, NULL, NULL);
     return PROJECTM_SUCCESS;
   }
 
@@ -1105,7 +1097,7 @@ int Parser::insert_gen_rec(Expr * gen_expr, TreeExpr * root)
 
   if ((root->right == NULL) && (root->infix_op != NULL))
   {
-    root->right = TreeExpr::create(NULL, gen_expr, NULL, NULL);
+    root->right = new TreeExpr(NULL, gen_expr, NULL, NULL);
     return PROJECTM_SUCCESS;
   }
 
@@ -1113,8 +1105,8 @@ int Parser::insert_gen_rec(Expr * gen_expr, TreeExpr * root)
      this succeeds then return. If it fails, try
      recursing down to the right */
 
-  if (insert_gen_rec(gen_expr, root->leftTree()) == PROJECTM_FAILURE)
-    return insert_gen_rec(gen_expr, root->rightTree());
+  if (insert_gen_rec(gen_expr, root->left) == PROJECTM_FAILURE)
+    return insert_gen_rec(gen_expr, root->right);
 
   /* Impossible for control flow to reach here, but in
      the world of C programming, who knows... */
@@ -1141,14 +1133,14 @@ int Parser::insert_infix_rec(InfixOp * infix_op, TreeExpr * root)
      I don't think this will ever happen */
   if (root->left == NULL)
   {
-    root->left = TreeExpr::create(infix_op, NULL, root->leftTree(), NULL);
+    root->left = new TreeExpr(infix_op, NULL, root->left, NULL);
     return PROJECTM_SUCCESS;
   }
 
   /* Right tree is empty, attach this operator to it */
   if (root->right == NULL)
   {
-    root->right = TreeExpr::create(infix_op, NULL, root->rightTree(), NULL);
+    root->right = new TreeExpr(infix_op, NULL, root->right, NULL);
     return PROJECTM_SUCCESS;
   }
 
@@ -1159,29 +1151,29 @@ int Parser::insert_infix_rec(InfixOp * infix_op, TreeExpr * root)
      then insert the expression here, attaching the old right branch
      to the left of the new expression */
 
-  if (root->rightTree()->infix_op == NULL)
+  if (root->right->infix_op == NULL)
   {
-    root->right = TreeExpr::create(infix_op, NULL, root->rightTree(), NULL);
+    root->right = new TreeExpr(infix_op, NULL, root->right, NULL);
     return PROJECTM_SUCCESS;
   }
 
   /* Traverse deeper if the inserting operator precedence is less than the
      the root's right operator precedence */
-  if (infix_op->precedence < root->rightTree()->infix_op->precedence)
-    return insert_infix_rec(infix_op, root->rightTree());
+  if (infix_op->precedence < root->right->infix_op->precedence)
+    return insert_infix_rec(infix_op, root->right);
 
   /* Otherwise, insert the operator here */
 
-  root->right = TreeExpr::create(infix_op, NULL, root->rightTree(), NULL);
+  root->right = new TreeExpr(infix_op, NULL, root->right, NULL);
   return PROJECTM_SUCCESS;
 
 }
 
 /* Parses an infix operator */
-Expr * Parser::parse_infix_op(std::istream &  fs, token_t token, TreeExpr * tree_expr, MilkdropPreset * preset)
+GenExpr * Parser::parse_infix_op(std::istream &  fs, token_t token, TreeExpr * tree_expr, MilkdropPreset * preset)
 {
 
-  Expr * gen_expr;
+  GenExpr * gen_expr;
 
   switch (token)
   {
@@ -1190,31 +1182,31 @@ Expr * Parser::parse_infix_op(std::istream &  fs, token_t token, TreeExpr * tree
     if (PARSE_DEBUG) printf("parse_infix_op: found addition operator (LINE %d)\n", line_count);
     if (PARSE_DEBUG) std::cerr << "WRAP AROUND IS " <<  tokenWrapAroundEnabled << std::endl;
 
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_add, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_add, &tree_expr), preset);
   case tMinus:
     if (PARSE_DEBUG) printf("parse_infix_op: found subtraction operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_minus, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_minus, &tree_expr), preset);
   case tMult:
     if (PARSE_DEBUG) printf("parse_infix_op: found multiplication operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_mult, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_mult, &tree_expr), preset);
   case tDiv:
     if (PARSE_DEBUG) printf("parse_infix_op: found division operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_div, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_div, &tree_expr), preset);
   case tMod:
     if (PARSE_DEBUG) printf("parse_infix_op: found modulo operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_mod, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_mod, &tree_expr), preset);
   case tOr:
     if (PARSE_DEBUG) printf("parse_infix_op: found bitwise or operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_or, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_or, &tree_expr), preset);
   case tAnd:
     if (PARSE_DEBUG) printf("parse_infix_op: found bitwise and operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_and, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_and, &tree_expr), preset);
   case tPositive:
     if (PARSE_DEBUG) printf("parse_infix_op: found positive operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_positive, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_positive, &tree_expr), preset);
   case tNegative:
     if (PARSE_DEBUG) printf("parse_infix_op: found negative operator (LINE %d)\n", line_count);
-    return _parse_gen_expr(fs, insert_infix_op(Eval::infix_negative, &tree_expr), preset);
+    return parse_gen_expr(fs, insert_infix_op(eval->infix_negative, &tree_expr), preset);
 
   case tEOL:
   case tEOF:
@@ -1222,12 +1214,12 @@ Expr * Parser::parse_infix_op(std::istream &  fs, token_t token, TreeExpr * tree
   case tRPr:
   case tComma:
     if (PARSE_DEBUG) printf("parse_infix_op: terminal found (LINE %d)\n", line_count);
-    gen_expr = tree_expr;
+    gen_expr = new GenExpr(TREE_T, (void*)tree_expr);
     assert(gen_expr);
     return gen_expr;
   default:
     if (PARSE_DEBUG) printf("parse_infix_op: operator or terminal expected, but not found (LINE %d)\n", line_count);
-    Expr::delete_expr(tree_expr);
+    delete tree_expr;
     return NULL;
   }
 
@@ -1252,11 +1244,11 @@ int Parser::parse_int(std::istream &  fs, int * int_ptr)
   {
   case tMinus:
     sign = -1;
-    parseToken(fs, string);
+    token = parseToken(fs, string);
     break;
   case tPlus:
     sign = 1;
-    parseToken(fs, string);
+    token = parseToken(fs, string);
     break;
   default:
     sign = 1;
@@ -1285,17 +1277,26 @@ int Parser::parse_int(std::istream &  fs, int * int_ptr)
 int Parser::string_to_float(char * string, float * float_ptr)
 {
 
+  char ** error_ptr;
+
   if (*string == 0)
     return PROJECTM_PARSE_ERROR;
 
-  std::istringstream iss(string);
-  iss.imbue(std::locale("C"));
-  iss >> (*float_ptr);
-  if (!iss.fail()) {
+  error_ptr = (char**)wipemalloc(sizeof(char**));
+
+  (*float_ptr) = strtod(string, error_ptr);
+
+  /* These imply a succesful parse of the string */
+  if ((**error_ptr == '\0') || (**error_ptr == '\r'))
+  {
+    free(error_ptr);
+    error_ptr = NULL;
     return PROJECTM_SUCCESS;
   }
 
   (*float_ptr) = 0;
+  free(error_ptr);
+  error_ptr = NULL;
   return PROJECTM_PARSE_ERROR;
 }
 
@@ -1304,20 +1305,23 @@ int Parser::parse_float(std::istream &  fs, float * float_ptr)
 {
 
   char string[MAX_TOKEN_SIZE];
+  char ** error_ptr;
   token_t token;
   int sign;
 
+  error_ptr =(char**) wipemalloc(sizeof(char**));
+
   token = parseToken(fs, string);
 
   switch (token)
   {
   case tMinus:
     sign = -1;
-    parseToken(fs, string);
+    token = parseToken(fs, string);
     break;
   case tPlus:
     sign = 1;
-    parseToken(fs, string);
+    token = parseToken(fs, string);
     break;
   default:
     sign = 1;
@@ -1325,20 +1329,26 @@ int Parser::parse_float(std::istream &  fs, float * float_ptr)
 
   if (string[0] == 0)
   {
+    free(error_ptr);
+    error_ptr = NULL;
     return PROJECTM_PARSE_ERROR;
   }
 
-  std::istringstream iss(string);
-  iss.imbue(std::locale("C"));
-  iss >> (*float_ptr);
-  if (!iss.fail()) {
-    (*float_ptr) *= sign;
+  (*float_ptr) = sign*strtod(string, error_ptr);
+
+  /* No conversion was performed */
+  if ((**error_ptr == '\0') || (**error_ptr == '\r'))
+  {
+    free(error_ptr);
+    error_ptr = NULL;
     return PROJECTM_SUCCESS;
   }
 
   if (PARSE_DEBUG) printf("parse_float: float conversion failed for string \"%s\"\n", string);
 
   (*float_ptr) = 0;
+  free(error_ptr);
+  error_ptr = NULL;
   return PROJECTM_PARSE_ERROR;
 
 }
@@ -1350,7 +1360,7 @@ PerFrameEqn * Parser::parse_per_frame_eqn(std::istream &  fs, int index, Milkdro
   char string[MAX_TOKEN_SIZE];
   Param * param;
   PerFrameEqn * per_frame_eqn;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
 
 
   if (parseToken(fs, string) != tEq)
@@ -1385,7 +1395,7 @@ PerFrameEqn * Parser::parse_per_frame_eqn(std::istream &  fs, int index, Milkdro
   if ((per_frame_eqn = new PerFrameEqn(index, param, gen_expr)) == NULL)
   {
     if (PARSE_DEBUG) printf("parse_per_frame_eqn: failed to create a new per frame eqn, out of memory?\n");
-    Expr::delete_expr(gen_expr);
+    delete gen_expr;
     return NULL;
   }
 
@@ -1400,14 +1410,11 @@ PerFrameEqn * Parser::parse_implicit_per_frame_eqn(std::istream &  fs, char * pa
 
   Param * param;
   PerFrameEqn * per_frame_eqn;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
 
-  if (fs.fail())
-    return NULL;
-  if (param_string == NULL)
-    return NULL;
-  if (preset == NULL)
-    return NULL;
+  assert(preset);
+  assert(fs);
+  assert(param_string);
 
   //rintf("param string: %s\n", param_string);
   /* Find the parameter associated with the string, create one if necessary */
@@ -1438,7 +1445,7 @@ PerFrameEqn * Parser::parse_implicit_per_frame_eqn(std::istream &  fs, char * pa
   if ((per_frame_eqn = new PerFrameEqn(index, param, gen_expr)) == NULL)
   {
     if (PARSE_DEBUG) printf("parse_implicit_per_frame_eqn: failed to create a new per frame eqn, out of memory?\n");
-    Expr::delete_expr(gen_expr);
+    delete gen_expr;
     return NULL;
   }
 
@@ -1531,11 +1538,15 @@ InitCond * Parser::parse_init_cond(std::istream &  fs, char * name, MilkdropPres
 
 void Parser::parse_string_block(std::istream &  fs, std::string * out_string) {
 
-	std::set<char> skipList;
-	skipList.insert('`');
-	readStringUntil(fs, out_string, false, skipList);
 
-	//std::cout << "out_string:\n " << *out_string << "\n" << std::endl;
+    char name[MAX_TOKEN_SIZE];
+    token_t token;
+
+    std::set<char> skipList;
+    skipList.insert('`');
+    readStringUntil(fs, out_string, false, skipList);
+
+    //std::cout << "out_string:\n " << *out_string << "\n" << std::endl;
 
 }
 
@@ -1546,15 +1557,13 @@ InitCond * Parser::parse_per_frame_init_eqn(std::istream &  fs, MilkdropPreset *
   Param * param = NULL;
   CValue init_val;
   InitCond * init_cond;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
   float val;
   token_t token;
 
 
-  if (preset == NULL)
-    return NULL;
-  if (fs.fail())
-    return NULL;
+  assert(preset);
+  assert(fs);
 
   if ((token = parseToken(fs, name)) != tEq)
     return NULL;
@@ -1592,10 +1601,10 @@ InitCond * Parser::parse_per_frame_init_eqn(std::istream &  fs, MilkdropPreset *
   }
 
   /* Compute initial condition value */
-  val = gen_expr->eval(-1,-1);
+  val = gen_expr->eval_gen_expr(-1,-1);
 
   /* Free the general expression now that we are done with it */
-  Expr::delete_expr(gen_expr);
+  delete gen_expr;
 
   /* integer value (boolean is an integer in C) */
   if (param->type == P_TYPE_BOOL)
@@ -1641,114 +1650,115 @@ bool Parser::scanForComment(std::istream & fs) {
   c = fs.get();
 
   if (c == '/') {
-	while (true)
-	{
-		if (!fs || fs.eof())
-			return true;
-		else
-			c = fs.get();
-		if (c == EOF)
-			return true;
-
-		if (c == '\n')
-		{
-			return true;
-		}
-	}
+    while (true)
+    {
+        if (!fs || fs.eof())
+            return true;
+        else
+            c = fs.get();
+        if (c == EOF)
+            return true;
+
+        if (c == '\n')
+        {
+            return true;
+        }
+    }
   } else {
-	fs.unget();
-	return false;
+    fs.unget();
+    return false;
   }
 }
 
 void Parser::readStringUntil(std::istream & fs, std::string * out_buffer, bool wrapAround, const std::set<char> & skipList) {
 
-	int c;
-
-	/* Loop until a delimiter is found, or the maximum string size is found */
-	while (true)
-	{
-
-		if (!fs || fs.eof())
-			c = EOF;
-		else
-			c = fs.get();
-
-		/* Now interpret the character */
-		switch (c)
-		{
-			case '/':
-			{
-				bool commentExisted = scanForComment(fs);
-				if (!commentExisted) {
-					out_buffer->push_back(c);
-					break;
-				} else {
-					line_count++;
-                    out_buffer->push_back('\n');
-					return;
-				}
-			}
-			case '\n':
-				if (!out_buffer->empty() && ((*out_buffer)[out_buffer->length() -1] == '\n'))
-					return;
-
-				line_count++;
-				if (wrapAround)
-				{
-					std::ostringstream buffer;
-
-		//			if (PARSE_DEBUG) std::cerr << "token wrap! line " << line_count << std::endl;
-					while (c != '=')
-					{
-
-						if (!fs || fs.eof())
-						{
-							line_count = 1;
-							line_mode = UNSET_LINE_MODE;
-		//					if (PARSE_DEBUG)     std::cerr << "token wrap: end of file" << std::endl;
-							return;
-						}
-
-						else {
-							c = fs.get();
-							if ( c != '=')
-								buffer << c;
-						}
-
-					}
-
-
-					if (!wrapsToNextLine(buffer.str())) {
-						int buf_size = (int)buffer.str().length();
-						// <= to also remove equal sign parsing from stream
-						for (int k = 0; k <= buf_size; k++) {
-							if (fs)
-								fs.unget();
-							else
-								abort();
-						}
-						return;
-					}
-
-					break;
-				} else
-					out_buffer->push_back(c);
-				return;
-			case EOF:
-				line_count = 1;
-				return;
-			default:
-
-				if (out_buffer != NULL)
-				{
-					if (skipList.find(c) == skipList.end())
-						out_buffer->push_back(c);
-
-				}
-		}
-
-	}
+    int string_line_buffer_index = 0;
+    int c;
+
+    /* Loop until a delimiter is found, or the maximum string size is found */
+    while (true)
+    {
+
+        if (!fs || fs.eof())
+            c = EOF;
+        else
+            c = fs.get();
+
+        /* Now interpret the character */
+        switch (c)
+        {
+            case '/':
+            {
+                bool commentExisted = scanForComment(fs);
+                if (!commentExisted) {
+                    out_buffer->push_back(c);
+                    break;
+                } else {
+                    line_count++;
+                    return;
+                }
+            }
+            case '\n':
+                if (!out_buffer->empty() && ((*out_buffer)[out_buffer->length() -1] == '\n'))
+                    return;
+
+                line_count++;
+                if (wrapAround)
+                {
+                    std::ostringstream buffer;
+
+        //            if (PARSE_DEBUG) std::cerr << "token wrap! line " << line_count << std::endl;
+                    while (c != '=')
+                    {
+
+                        if (!fs || fs.eof())
+                        {
+                            line_count = 1;
+                            line_mode = UNSET_LINE_MODE;
+        //                    if (PARSE_DEBUG)     std::cerr << "token wrap: end of file" << std::endl;
+                            return;
+                        }
+
+                        else {
+                            c = fs.get();
+                            if ( c != '=')
+                                buffer << c;
+                        }
+
+                    }
+
+
+                    if (!wrapsToNextLine(buffer.str())) {
+                        wrapAround = false;
+                        int buf_size = (int)buffer.str().length();
+                        // <= to also remove equal sign parsing from stream
+                        for (int k = 0; k <= buf_size; k++) {
+                            if (fs)
+                                fs.unget();
+                            else
+                                abort();
+                        }
+                        return;
+                    }
+
+                    break;
+                } else
+                    out_buffer->push_back(c);
+                return;
+            case EOF:
+                line_count = 1;
+                return;
+            default:
+
+                if (out_buffer != NULL)
+                {
+                    if (skipList.find(c) == skipList.end())
+                        out_buffer->push_back(c);
+
+                }
+        }
+
+    }
 
 
 }
@@ -1842,7 +1852,10 @@ int Parser::parse_wavecode(char * token, std::istream &  fs, MilkdropPreset * pr
     return PROJECTM_FAILURE;
   }
 
-  custom_wave->init_cond_tree.insert(std::make_pair(init_cond->param->name, init_cond));
+  std::pair<std::map<std::string, InitCond*>::iterator, bool> inserteePair =
+    custom_wave->init_cond_tree.insert(std::make_pair(init_cond->param->name, init_cond));
+
+ // assert(inserteePair.second);
 
   line_mode = CUSTOM_WAVE_WAVECODE_LINE_MODE;
 
@@ -1861,12 +1874,9 @@ int Parser::parse_shapecode(char * token, std::istream &  fs, MilkdropPreset * p
   Param * param;
 
   /* Null argument checks */
-  if (preset == NULL)
-    return PROJECTM_FAILURE;
-  if (fs.fail())
-    return PROJECTM_FAILURE;
-  if (token == NULL)
-    return PROJECTM_FAILURE;
+    assert(preset);
+    assert(fs);
+    assert(token);
 
   /* token should be in the form shapecode_N_var, such as shapecode_1_samples */
 
@@ -1897,7 +1907,7 @@ int Parser::parse_shapecode(char * token, std::istream &  fs, MilkdropPreset * p
 
     fs >> text;
 
-    param->set_param(text);
+    *((std::string*)param->engine_val) = text;
     if (PARSE_DEBUG)
       std::cerr << "parse_shapecode: found image url, text is \""
       << text << "\"" << std::endl;
@@ -1974,14 +1984,8 @@ int Parser::parse_wavecode_prefix(char * token, int * id, char ** var_string)
 
   int len, i, j;
 
-  if (token == NULL)
-    return PROJECTM_FAILURE;
-  /*
-  if (*var_string == NULL)
-    return PROJECTM_FAILURE;
-  */
-  if (id == NULL)
-    return PROJECTM_FAILURE;
+  assert(id);
+  assert(token);
 
   len = strlen(token);
 
@@ -2152,12 +2156,9 @@ int Parser::parse_wave(char * token, std::istream &  fs, MilkdropPreset * preset
 
   if (PARSE_DEBUG) printf("parse_wave:begin\n");
 
-  if (token == NULL)
-    return PROJECTM_FAILURE;
-  if (fs.fail())
-    return PROJECTM_FAILURE;
-  if (preset == NULL)
-    return PROJECTM_FAILURE;
+  assert(preset);
+  assert(fs);
+  assert(token);
 
   /* Grab custom wave id and equation type (per frame or per point) from string token */
   if (parse_wave_prefix(token, &id, &eqn_type) < 0)
@@ -2176,7 +2177,7 @@ int Parser::parse_wave_helper(std::istream &  fs, MilkdropPreset  * preset, int
 {
 
   Param * param;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
   char string[MAX_TOKEN_SIZE];
   PerFrameEqn * per_frame_eqn;
   CustomWave * custom_wave;
@@ -2257,7 +2258,7 @@ int Parser::parse_wave_helper(std::istream &  fs, MilkdropPreset  * preset, int
     if ((per_frame_eqn = new PerFrameEqn(custom_wave->per_frame_count++, param, gen_expr)) == NULL)
     {
       if (PARSE_DEBUG) printf("parse_wave (per_frame): failed to create a new per frame eqn, out of memory?\n");
-      Expr::delete_expr(gen_expr);
+      delete gen_expr;
       return PROJECTM_FAILURE;
     }
 
@@ -2283,7 +2284,7 @@ int Parser::parse_wave_helper(std::istream &  fs, MilkdropPreset  * preset, int
     /// HACK the parse_line code already parsed the per_pixel variable name. This handles that case
     /// Parser needs reworked. Don't have time for it. So this is the result.
     if (init_string)
-      memcpy(string, init_string, strlen(init_string)+1);
+      strncpy(string, init_string, strlen(init_string)+1);
     else
     {
       if (parseToken(fs, string) != tEq)
@@ -2299,7 +2300,7 @@ int Parser::parse_wave_helper(std::istream &  fs, MilkdropPreset  * preset, int
     if ((gen_expr = parse_gen_expr(fs, NULL, preset)) == NULL)
     {
       if (PARSE_DEBUG) printf("parse_wave_helper (per_point): equation evaluated to null? (LINE %d)\n", line_count);
-      current_wave = NULL;
+
       return PROJECTM_PARSE_ERROR;
     }
 
@@ -2307,8 +2308,8 @@ int Parser::parse_wave_helper(std::istream &  fs, MilkdropPreset  * preset, int
     /* Add the per point equation */
     if (custom_wave->add_per_point_eqn(string, gen_expr) < 0)
     {
-      Expr::delete_expr(gen_expr);
-      current_wave = NULL;
+      delete gen_expr;
+
       return PROJECTM_PARSE_ERROR;
     }
     // This tells the parser we are no longer parsing a custom wave
@@ -2333,13 +2334,10 @@ int Parser::parse_shape(char * token, std::istream &  fs, MilkdropPreset * prese
   CustomShape * custom_shape;
 
 
-  if (token == NULL)
+  assert(preset);
+  assert(fs);
+  assert(token);
 
-    return PROJECTM_FAILURE;
-  if (fs.fail())
-    return PROJECTM_FAILURE;
-  if (preset == NULL)
-    return PROJECTM_FAILURE;
 
   /* Grab custom shape id and equation type (per frame or per point) from string token */
   if (parse_shape_prefix(token, &id, &eqn_type) < 0)
@@ -2352,7 +2350,6 @@ int Parser::parse_shape(char * token, std::istream &  fs, MilkdropPreset * prese
   if ((custom_shape = MilkdropPreset::find_custom_object(id,preset->customShapes)) == NULL)
     return PROJECTM_FAILURE;
 
-
   /* per frame init equation case */
   if (!strncmp(eqn_type, SHAPE_INIT_STRING, SHAPE_INIT_STRING_LENGTH))
   {
@@ -2435,8 +2432,6 @@ int Parser::parse_shape_per_frame_init_eqn(std::istream &  fs, CustomShape * cus
 
   line_mode = CUSTOM_SHAPE_PER_FRAME_INIT_LINE_MODE;
   init_cond->evaluate(true);
-
-  delete init_cond;
   return PROJECTM_SUCCESS;
 }
 
@@ -2444,7 +2439,7 @@ int Parser::parse_shape_per_frame_eqn(std::istream & fs, CustomShape * custom_sh
 {
 
   Param * param;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
   PerFrameEqn * per_frame_eqn;
 
   char string[MAX_TOKEN_SIZE];
@@ -2490,7 +2485,7 @@ int Parser::parse_shape_per_frame_eqn(std::istream & fs, CustomShape * custom_sh
   if ((per_frame_eqn = new PerFrameEqn(custom_shape->per_frame_count++, param, gen_expr)) == NULL)
   {
     if (PARSE_DEBUG) printf("parse_shape (per_frame): failed to create a new per frame eqn, out of memory?\n");
-    Expr::delete_expr(gen_expr);
+    delete gen_expr;
     return PROJECTM_FAILURE;
   }
 
@@ -2506,7 +2501,7 @@ int Parser::parse_wave_per_frame_eqn(std::istream &  fs, CustomWave * custom_wav
 {
 
   Param * param;
-  Expr * gen_expr;
+  GenExpr * gen_expr;
   PerFrameEqn * per_frame_eqn;
 
   char string[MAX_TOKEN_SIZE];
@@ -2552,7 +2547,7 @@ int Parser::parse_wave_per_frame_eqn(std::istream &  fs, CustomWave * custom_wav
   if ((per_frame_eqn = new PerFrameEqn(custom_wave->per_frame_count++, param, gen_expr)) == NULL)
   {
     if (PARSE_DEBUG) printf("parse_wave (per_frame): failed to create a new per frame eqn, out of memory?\n");
-    Expr::delete_expr(gen_expr);
+    delete gen_expr;
     return PROJECTM_FAILURE;
   }
 
@@ -2572,156 +2567,15 @@ int Parser::parse_wave_per_frame_eqn(std::istream &  fs, CustomWave * custom_wav
 bool Parser::wrapsToNextLine(const std::string & str) {
 
 std::size_t lastLineEndIndex =
-	lastLinePrefix.find_last_not_of("0123456789");
+    lastLinePrefix.find_last_not_of("0123456789");
 
 std::size_t thisLineEndIndex =
-	str.find_last_not_of("0123456789");
+    str.find_last_not_of("0123456789");
 
 std::size_t startIndex = 0;
 if ((str.compare(startIndex, lastLineEndIndex, lastLinePrefix.c_str(), thisLineEndIndex)) == 0)
-	return true;
+    return true;
 else
-	return false;
-
-}
-
-
-
-
-
-
-
-// TESTS
-
-
-#include <TestRunner.hpp>
-
-#ifndef NDEBUG
-
-#include <PresetLoader.hpp>
-
-#define TEST(cond) if (!verify(#cond,cond)) return false
-#define TEST2(str,cond) if (!verify(str,cond)) return false
-
-struct ParserTest : public Test
-{
-    ParserTest() : Test("ParserTest")
-    {}
+    return false;
 
-    MilkdropPreset *preset;
-    std::istringstream is;
-    std::istringstream &ss(const char *s) { return is = std::istringstream(s); }
-
-    bool eq(float a, float b)
-    {
-        return std::abs(a-b) < (std::abs(a)+std::abs(b) + 1)/1000.0f;
-    }
-
-public:
-
-    bool test_float()
-    {
-        float f=-1.0f;
-        TEST(PROJECTM_SUCCESS == Parser::parse_float(ss("1.1"),&f));
-        TEST(1.1f == f);
-        TEST(PROJECTM_SUCCESS == Parser::parse_float(ss("+1.2"),&f));
-        TEST(PROJECTM_SUCCESS == Parser::parse_float(ss("-1.3"),&f));
-        TEST(PROJECTM_PARSE_ERROR == Parser::parse_float(ss(""),&f));
-        TEST(PROJECTM_PARSE_ERROR == Parser::parse_float(ss("\n"),&f));
-        TEST(PROJECTM_PARSE_ERROR == Parser::parse_float(ss("+"),&f));
-        return true;
-    }
-
-    bool test_int()
-    {
-        int i=-1;
-        TEST(PROJECTM_SUCCESS == Parser::parse_int(ss("1"),&i));
-        TEST(1 == i);
-        TEST(PROJECTM_SUCCESS == Parser::parse_int(ss("+2"),&i));
-        TEST(PROJECTM_SUCCESS == Parser::parse_int(ss("-3"),&i));
-        TEST(PROJECTM_PARSE_ERROR == Parser::parse_int(ss(""),&i));
-        TEST(PROJECTM_PARSE_ERROR == Parser::parse_int(ss("\n"),&i));
-        TEST(PROJECTM_PARSE_ERROR == Parser::parse_int(ss("+"),&i));
-        return true;
-    }
-
-    bool eval_expr(float expected, const char *s)
-    {
-        float result;
-        Expr *expr_parse = Parser::parse_gen_expr(ss(s),nullptr,preset);
-        TEST(expr_parse != nullptr);
-        // Expr doesn't really expect to run 'non-optimized' expressions any longer
-        Expr *expr = Expr::optimize(expr_parse);
-        expr_parse = nullptr;
-        if (!ParserTest::eq(expected, result=expr->eval(-1,-1)))
-        {
-            std::cout << "failed: expected " << expected << " found " << result << std::endl;
-            return false;
-        }
-        Expr::delete_expr(expr);
-        return true;
-    }
-
-    bool test_eqn()
-    {
-        TEST(eval_expr(1.0f, "1.0"));
-        TEST(eval_expr(-1.0f, "-(1.0)"));         // unary`
-        TEST(eval_expr(0.5f, "5/10.000"));        // binary
-        TEST(eval_expr(1.0f, "sin(3.14159/2)"));
-        preset->presetOutputs().rot = 0.99f;
-        TEST(eval_expr(0.99f, "rot"));
-        return true;
-    }
-
-    // test multi-line expression, and multi-expression line
-    bool test_lines()
-    {
-        // TODO
-        return true;
-    }
-
-    bool test_params()
-    {
-        // TODO
-        return true;
-    }
-
-
-    bool _test()
-    {
-        bool success = true;
-        success &= test_float();
-        success &= test_int();
-        success &= test_eqn();
-        success &= test_lines();
-        success &= test_params();
-        return success;
-    }
-
-    bool test() override
-    {
-        // load IdlePreset
-        PresetLoader *presetLoader = new PresetLoader ( 400, 400, "" );
-        std::unique_ptr<Preset> preset_ptr = presetLoader->loadPreset("idle://Geiss & Sperl - Feedback (projectM idle HDR mix).milk");
-        preset = (MilkdropPreset *)preset_ptr.get();
-
-        bool success = _test();
-
-        delete presetLoader;
-        return success;
-    }
-};
-
-Test* Parser::test()
-{
-  return new ParserTest();
 }
-
-#else
-
-Test* Parser::test()
-{
-    return nullptr;
-}
-
-#endif
diff --git a/src/libprojectM/MilkdropPresetFactory/Parser.hpp b/src/libprojectM/MilkdropPresetFactory/Parser.hpp
index edcf5c35..1ab9bd7e 100755
--- a/src/libprojectM/MilkdropPresetFactory/Parser.hpp
+++ b/src/libprojectM/MilkdropPresetFactory/Parser.hpp
@@ -128,6 +128,9 @@ class InfixOp;
 class PerFrameEqn;
 class MilkdropPreset;
 class TreeExpr;
+class Eval;
+class BuiltinFuncs;
+class GenExpr;
 
 class Parser {
 public:
@@ -145,6 +148,11 @@ public:
     static char last_eqn_type[MAX_TOKEN_SIZE+1];
     static int last_token_size;
     static bool tokenWrapAroundEnabled;
+    static Eval *eval;
+    static BuiltinFuncs *builtinFuncs;
+    
+    Parser();
+    ~Parser();
 
     static Test *test();
     static PerFrameEqn *parse_per_frame_eqn( std::istream & fs, int index,
@@ -157,17 +165,17 @@ public:
     static int parse_line( std::istream & fs, MilkdropPreset * preset );
 
     static int get_string_prefix_len(char * string);
-    static TreeExpr * insert_gen_expr(Expr * gen_expr, TreeExpr ** root);
+    static TreeExpr * insert_gen_expr(GenExpr * gen_expr, TreeExpr ** root);
     static TreeExpr * insert_infix_op(InfixOp * infix_op, TreeExpr ** root);
     static token_t parseToken(std::istream & fs, char * string);
-    static Expr ** parse_prefix_args(std::istream & fs, int num_args, MilkdropPreset * preset);
-    static Expr * parse_infix_op(std::istream & fs, token_t token, TreeExpr * tree_expr, MilkdropPreset * preset);
+    static GenExpr ** parse_prefix_args(std::istream & fs, int num_args, MilkdropPreset * preset);
+    static GenExpr * parse_infix_op(std::istream & fs, token_t token, TreeExpr * tree_expr, MilkdropPreset * preset);
     static Expr * parse_sign_arg(std::istream & fs);
     static int parse_float(std::istream & fs, float * float_ptr);
     static int parse_int(std::istream & fs, int * int_ptr);
     static int insert_gen_rec(Expr * gen_expr, TreeExpr * root);
     static int insert_infix_rec(InfixOp * infix_op, TreeExpr * root);
-    static Expr * parse_gen_expr(std::istream & fs, TreeExpr * tree_expr, MilkdropPreset * preset);
+    static GenExpr * parse_gen_expr(std::istream & fs, TreeExpr * tree_expr, MilkdropPreset * preset);
     static PerFrameEqn * parse_implicit_per_frame_eqn(std::istream & fs, char * param_string, int index, MilkdropPreset * preset);
     static InitCond * parse_per_frame_init_eqn(std::istream & fs, MilkdropPreset * preset, std::map<std::string,Param*> * database);
     static int parse_wavecode_prefix(char * token, int * id, char ** var_string);
